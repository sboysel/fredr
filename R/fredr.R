#' Send a request to the FRED API
#'
#' \code{\link[fredr]{fredr}} forms and submits a request to a specified endpoint of the FRED API.
#'
#' @param endpoint A string representing the FRED API endpoint of interest. See
#'        \code{fredr_endpoints} for a list of endpoint possible values.
#' @param ... A series of named parameters to be used in the query.  Must be of the form
#'        \code{param_key = "param_value"}.  Acceptable parameters are endpoint-specific.
#'        See  \code{\link{fredr_endpoints}} for a list of endpoints and \code{\link{fredr_docs}}
#'        access to the endpoint web documentation.
#' @param to_frame A boolean value indicating whether or not the response
#'        should be parsed and formatted as a data frame.  If \code{FALSE},
#'        a \code{response} object is returned and further processing can be done with
#'        \code{\link[httr]{content}}.  Default is \code{TRUE}.
#' @param print_req A boolean value indicating whether or not the request
#'        should be printed as well.  Useful for debugging.  Default is \code{FALSE}.
#' @return If \code{to_frame = TRUE}, a data frame containing the parsed response.
#'         If \code{to_frame = FALSE}, an object returned directly from \code{\link[httr]{GET}}.
#'
#' @references \url{https://api.stlouisfed.org/docs/fred/}.
#' @seealso \code{\link[fredr]{fredr_docs}}, \code{\link[fredr]{fredr_search}}, \code{\link[fredr]{fredr_series}}
#'
#' @examples
#' fredr(
#'   endpoint = "series/observations",
#'   series_id = "GNPCA",
#'   observation_start = "1990-01-01",
#'   observation_end = "2000-01-01"
#' )
#' \dontrun{
#' # Compare with to_frame = TRUE
#' library(httr)
#' library(tidyverse)
#' resp <- fredr(
#'   endpoint = "series/observations",
#'   series_id = "GNPCA",
#'   observation_start = "1990-01-01",
#'   observation_end = "2000-01-01",
#'   to_frame = FALSE
#' )
#' data <- resp %>%
#' httr::content() %>%
#'   .$observations %>%
#'   purrr::map_df(.f = function(x) tibble::as_tibble(x = x))
#' }
#' @export
fredr <- function(endpoint, ..., to_frame = TRUE, print_req = FALSE) {

  if (identical(Sys.getenv("FRED_API_KEY"), "")) {
    stop("FRED API key must be set. Use fredr_key().")
  }

  params <- list(...)
  params$api_key <- Sys.getenv("FRED_API_KEY")
  params$file_type <- "json"

  resp <- httr::GET(
    url = "https://api.stlouisfed.org/",
    path = paste0("fred/", endpoint),
    query = params
  )

  if (print_req) {
    message(resp$url)
  }

  if (resp$status_code != 200) {
    err <- httr::content(resp, "text")
    stop(paste0(err$error_code, ": ", err$error_message))
  }

  if (to_frame) {
    parsed <- httr::content(resp, "text")
    if (endpoint %in% c("category",
                        "category/children",
                        "category/related",
                        "series/categories")) {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$categories)
    }
    if (endpoint == "category/series") {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$series)
    }
    if (endpoint %in% c("category/tags",
                        "category/related_tags",
                        "release/tags",
                        "release/related_tags",
                        "series/search/tags",
                        "series/search/related_tags",
                        "series/tags",
                        "tags",
                        "related_tags")) {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$tags)
    }
    if (endpoint %in% c("releases",
                        "release",
                        "series/release",
                        "source/releases")) {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$releases)
    }
    if (endpoint %in% c("releases/dates",
                        "release/dates")) {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$release_dates)
    }
    if (endpoint %in% c("release/series",
                        "series",
                        "series/search",
                        "series/updates",
                        "tags/series")) {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$seriess)
    }
    if (endpoint == "release/sources") {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$sources)
    }
    if (endpoint == "series/observations") {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$observations)
    }
    if (endpoint == "series/vintagedates") {
      frame <- unlist(parsed$vintage_dates)
    }
    if (endpoint %in% c("source",
                        "sources")) {
      frame <- tibble::as_tibble(jsonlite::fromJSON(parsed)$sources)
    }
    return(frame)
  } else {
    return(resp)
  }
}
